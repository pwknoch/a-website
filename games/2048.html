<!doctype HTML>

<style>
    .container{
        width: 40%;
        margin: 0 auto;
        transition: all 1s;
    }

    .game-board{
        display: flex;
        flex-direction: column;
    }

    .game-row{
        display: flex;
        flex-direction: row;
    }

    .game-cell{
        flex: 1;
        border: 1px black solid;
        border-radius: 25px;
        text-align: center;
        padding: 50px;
        font-size: 3em;
    }
</style>

<div class="container">
    <div class="game-board">
        <div class="game-row">
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
        </div>
        <div class="game-row">
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
        </div>
        <div class="game-row">
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
        </div>
        <div class="game-row">
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
            <div class="game-cell"></div>
        </div>
    </div>
</div>

<script type="text/javascript">
    //if we have an array that is 4 x 4, then we assume that the origin is at the lower left hand corner of the array, at [0][0]. To it's left would be [1][0], and above it would be [0][1].
    var gameBoard = [];
    for(i = 0; i < 4; i++){
        gameBoard.push([]);
        for(z = 0; z < 4; z++){
            gameBoard[i][z] = {value: 0, merged: false};
        }
    }

    var possibleKeys = ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'];

    function getTileAbove(x, y)
    {
        if(x - 1 < 0) {
            return null;
        }

        return gameBoard[x - 1][y];
    }

    function getTileBelow(x, y)
    {
        if(x + 1 > 3) {
            return null;
        }

        return gameBoard[x + 1][y];
    }

    function getTileLeft(x, y)
    {
        if(y - 1 < 0){
            return null;
        }

        return gameBoard[x][y - 1];
    }

    function getTileRight(x, y)
    {
        if(y + 1 > 3) {
            return null;
        }

        return gameBoard[x][y + 1];
    }

    function findFreeSpots()
    {
        //TODO: rewrite using new loop function
        var freeSpots = [];
        for (let index = 0; index < gameBoard.length; index++) {
            for(let index2 = 0; index2 < gameBoard.length; index2++) {
                if(gameBoard[index][index2].value == 0) {
                    freeSpots.push([index, index2]);
                }
            }
        }

        return freeSpots;
    }

    function createTile(freeSpots)
    {
        var tile = freeSpots[getRandomInt(freeSpots.length)];
        gameBoard[tile[0]][tile[1]].value = 2;
    }

    function getRandomInt(max) {
        return Math.floor(Math.random() * Math.floor(max));
    }

    function shiftLeft() {
        var moved = false;
        for (let x = 0; x < gameBoard.length; x++) {
            for(let y = 3; y >= 0; y--) {
                var currentTile = gameBoard[x][y];
                var leftTile = getTileLeft(x, y);

                // if there is no tile to the left, ignore this, it's one of the edges of the board.
                // also ignore if the current line is empty
                if(leftTile == null || currentTile.value == 0) continue;

                // if there is a tile to the left, and it has the same value, then let's merge.
                if(leftTile.value == currentTile.value && !leftTile.merged && !currentTile.merged) {
                    moved = true;

                    leftTile.value = leftTile.value * 2;
                    leftTile.merged = true;
                    currentTile.value = 0;
                }

                // if there is an empty tile to the left, shift.
                if(leftTile.value == 0) {
                    moved = true;

                    leftTile.value = currentTile.value;
                    leftTile.merged = currentTile.merged;
                    currentTile.value = 0;
                    currentTile.merged = false
                }
            }
        }

        return moved;
    }

    function shiftRight() {
        var moved = false;
        for (let x = 0; x < gameBoard.length; x++) {
            for(let y = 0; y < gameBoard.length; y++) {
                var currentTile = gameBoard[x][y];
                var rightTile = getTileRight(x, y);

                // if there is no tile to the right, ignore this, it's one of the edges of the board.
                // also ignore if the current line is empty
                if(rightTile == null || currentTile.value == 0) continue;

                // if there is a tile to the right, and it has the same value, then let's merge.
                if(rightTile.value == currentTile.value && !rightTile.merged && !currentTile.merged) {
                    moved = true;

                    rightTile.value = rightTile.value * 2;
                    rightTile.merged = true;
                    currentTile.value = 0;
                }

                // if there is an empty tile to the right, shift.
                if(rightTile.value == 0) {
                    moved = true;

                    rightTile.value = currentTile.value;
                    rightTile.merged = currentTile.merged;
                    currentTile.value = 0;
                    currentTile.merged = false
                }
            }
        }

        return moved;
    }

    function shiftUp() {
        var moved = false;
        for (let y = 0; y < gameBoard.length; y++) {
            for(let x = 3; x >= 0; x--) {
                var currentTile = gameBoard[x][y];
                var aboveTile = getTileAbove(x, y);

                // if there is no tile to the above, ignore this, it's one of the edges of the board.
                // also ignore if the current line is empty
                if(aboveTile == null || currentTile.value == 0) continue;

                // if there is a tile to the above, and it has the same value, then let's merge.
                if(aboveTile.value == currentTile.value && !aboveTile.merged && !currentTile.merged) {
                    moved = true;

                    aboveTile.value = aboveTile.value * 2;
                    aboveTile.merged = true;
                    currentTile.value = 0;
                }

                // if there is an empty tile to the above, shift.
                if(aboveTile.value == 0) {
                    moved = true;

                    aboveTile.value = currentTile.value;
                    aboveTile.merged = currentTile.merged;
                    currentTile.value = 0;
                    currentTile.merged = false
                }
            }
        }

        return moved;
    }

    function shiftDown() {
        var moved = false;
        for (let y = 0; y < gameBoard.length; y++) {
            for(let x = 0; x < gameBoard.length; x++) {
                var currentTile = gameBoard[x][y];
                var belowTile = getTileBelow(x, y);

                // if there is no tile to the below, ignore this, it's one of the edges of the board.
                // also ignore if the current line is empty
                if(belowTile == null || currentTile.value == 0) continue;

                // if there is a tile to the below, and it has the same value, then let's merge.
                if(belowTile.value == currentTile.value && !belowTile.merged && !currentTile.merged) {
                    moved = true;

                    belowTile.value = belowTile.value * 2;
                    belowTile.merged = true;
                    currentTile.value = 0;
                }

                // if there is an empty tile to the below, shift.
                if(belowTile.value == 0) {
                    moved = true;

                    belowTile.value = currentTile.value;
                    belowTile.merged = currentTile.merged;
                    currentTile.value = 0;
                    currentTile.merged = false
                }
            }
        }

        return moved;
    }

    function loopBoard(foo) {
        for (let x = 0; x < gameBoard.length; x++) {
            for (let y = 0; y < gameBoard.length; y++) {
                foo(x, y);
            }
        }
    }

    function clearMerged(){
        loopBoard((x, y) => gameBoard[x][y].merged = false);
    }

    document.addEventListener('keyup', function(e) {
        if(!possibleKeys.includes(e.key)) return;

        var moved = false;
        switch (e.key) {
            case 'ArrowLeft':
                moved = shiftLeft();
                if(moved) shiftLeft();
                break;
            case 'ArrowRight':
                moved = shiftRight();
                if(moved) shiftRight();
                break;
            case 'ArrowUp':
                moved = shiftUp();
                if(moved) shiftUp();
                break;
            case 'ArrowDown':
                moved = shiftDown();
                if(moved) shiftDown();
                break;
            default:
                break;
        }
        
        if(moved) {
            createTile(findFreeSpots());
        }

        clearMerged();
        drawBoard();

        console.table(gameBoard);
    });

    function drawBoard() {
        let htmlBoard = document.querySelector('.game-board');
        htmlBoard.innerHTML = '';

        for (let x = 0; x < gameBoard.length; x++) {
            var row = document.createElement('div');
            row.classList.add('game-row');
            for (let y = 0; y < gameBoard.length; y++) {
                var cell = document.createElement('div');
                cell.classList.add('game-cell');
                cell.innerHTML = gameBoard[x][y].value;
                row.appendChild(cell);
            }

            htmlBoard.appendChild(row);
        }
    }

    createTile(findFreeSpots());
    drawBoard();
</script>